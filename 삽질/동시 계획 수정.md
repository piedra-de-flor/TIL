# 계획 동시 수정 기능을 위한 CS

## 1. 동시성(Concurrency)과 병행성(Parallelism)

### 개념
- **동시성**: 여러 작업이 병렬이든 순차든 "동시에" 실행되는 것처럼 보이게 설계
- **병행성**: 실제로 여러 작업이 동시에 수행됨 (멀티코어 활용)

### 연관성
- 여러 사용자가 동시에 같은 계획을 수정할 수 있으므로 동시성 처리 필수

---

## 2. 낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)

### Optimistic Lock
- 데이터 수정 시점에 충돌을 검사 (e.g., version 필드)
- 충돌 발생 시 사용자에게 알려줌 (ex. “수정 내용 충돌 발생”)

### Pessimistic Lock
- 데이터를 읽을 때부터 잠금을 걸어 다른 사용자의 접근 제한

### 선택 기준
- 대부분의 경우 충돌이 드물다면 **낙관적 락**이 적합

---

## 3. 분산 시스템 이론

### CAP 이론
- **Consistency**: 모든 노드가 같은 데이터를 가진다
- **Availability**: 항상 응답을 제공한다
- **Partition Tolerance**: 네트워크 분할 상황에서도 동작한다

### 관련성
- 계획 동시 수정 기능은 **Availability**와 **Consistency**의 균형 필요

---

## 4. CRDT (Conflict-free Replicated Data Type)

### 개념
- 분산 환경에서 충돌 없이 병합 가능한 자료구조
- 예: GCounter, GSet, RGA, LWW-Element-Set 등

### 용도
- Google Docs처럼 실시간 편집 동기화 구현 시 사용
- 클라이언트 단에서 병합이 자동으로 가능함

---

## 5. OT (Operational Transformation)

### 개념
- 실시간 협업 편집 시, 사용자의 입력(작업)을 순서에 따라 변환하여 적용
- 상대 작업의 영향 고려하여 수정 내용 보정

### 사례
- Google Docs, Etherpad 등 실시간 문서 편집기

---

## 6. 데이터 정합성 및 무결성

### 개념
- 계획 데이터의 일관된 상태 유지
- 예: 시간 중복 불가, 날짜 유효성, 작성자 권한 확인

### 적용
- 동시 수정 시 데이터 유효성 체크 로직 필요

---

## 7. 이벤트 소싱 & CQRS (Command Query Responsibility Segregation)

### 개념
- **이벤트 소싱**: 모든 상태 변경을 이벤트로 기록
- **CQRS**: 명령(Command)과 조회(Query)를 분리

### 적용
- 모든 변경 사항을 이벤트로 기록하고 버전 관리 가능
- 복구 및 충돌 분석에도 유용

---

## 8. WebSocket / SSE (Server-Sent Events)

### 개념
- WebSocket: 클라이언트-서버 간 양방향 실시간 통신
- SSE: 서버 → 클라이언트 단방향 실시간 통신

### 용도
- 실시간 수정사항 동기화, 알림 기능

---

## 9. Lock Granularity (락의 세분화)

### 개념
- 계획 전체 vs. 세부 항목 수준 락
- Field-level, Row-level, Document-level lock

### 전략
- 너무 세분화하면 복잡성 증가
- 적절한 수준의 분할 필요 (e.g., 한 날짜 내 일정만 락)

---

## 10. 버전 관리 전략

### 방법
- `version` 필드를 이용해 충돌 검출
- 충돌 발생 시: 사용자 병합, 알림, 재시도 제공

### 예시
```json
{
  "planId": 123,
  "version": 4,
  "data": {
    "title": "회의",
    "time": "2025-07-11 14:00"
  }
}
```

## 11. Undo / Redo, History 관리

### 개념
- 사용자가 이전 상태로 되돌릴 수 있도록 상태 변경 이력을 저장하는 기능
- **Command Pattern** 또는 **이벤트 로그(Event Log)** 방식으로 구현 가능

### 전략
- 변경 작업마다 상태 스냅샷 또는 diff 저장
- 되돌리기 시 과거 상태 복원
- Redo는 Undo의 반대 방향으로 진행

### 예시
- 사용자 A가 계획을 10:00 → 11:00으로 변경하면 다음과 같은 로그 기록
```json
[
  {
    "type": "update_time",
    "before": "10:00",
    "after": "11:00",
    "timestamp": "2025-07-11T13:00:00Z",
    "user": "userA"
  }
]
```

## 12. DB 트랜잭션과 ACID

### ACID란?

| 항목          | 설명                                                                 |
|---------------|----------------------------------------------------------------------|
| **Atomicity** | 트랜잭션은 전부 실행되거나 전혀 실행되지 않아야 한다 (모두 또는 무) |
| **Consistency** | 트랜잭션 완료 후에도 데이터는 일관된 상태를 유지해야 한다              |
| **Isolation** | 여러 트랜잭션이 동시에 실행돼도 서로 간섭하지 않아야 한다             |
| **Durability** | 트랜잭션이 성공적으로 끝나면 그 결과는 영구적으로 저장돼야 한다       |

### 트랜잭션 격리 수준 (Isolation Level)

| 수준                | 설명                                                                | 장점                          | 단점                         |
|---------------------|---------------------------------------------------------------------|-------------------------------|------------------------------|
| **Read Uncommitted** | 커밋되지 않은 데이터를 읽을 수 있음 (Dirty Read 허용)             | 빠름                           | 정합성 매우 취약             |
| **Read Committed**   | 커밋된 데이터만 읽음 (Dirty Read 방지)                             | 일반적인 트랜잭션에 적합       | 반복 읽기 결과가 달라질 수 있음 |
| **Repeatable Read**  | 동일 쿼리 결과는 항상 동일함 (Phantom Read는 발생 가능)           | 대부분의 정합성 요구 충족      | 성능 저하 가능               |
| **Serializable**     | 트랜잭션을 순차적으로 실행하는 것처럼 보이게 함 (가장 안전)        | 완전한 정합성 보장             | 동시성 성능 저하, 락 과다    |

### 동시 수정 기능에서의 활용

- **트랜잭션으로 감싸기**: 계획 수정 작업은 트랜잭션 단위로 실행해 정합성 보장
- **낙관적 락** + **트랜잭션 충돌 감지**: `version` 컬럼 기반 충돌 감지 후 rollback
- **계획 병합 후 커밋**: 사용자 병합이 완료된 후 최종 상태를 트랜잭션으로 커밋
- **일관성 유지**: 계획 간 참조(예: 일정 겹침 여부)도 트랜잭션 안에서 처리

---

## 13. 실시간 협업 시스템 사례 분석

| 서비스        | 기술 기반     | 충돌 처리 방식                    | 특징                                                       |
|---------------|----------------|------------------------------------|------------------------------------------------------------|
| **Google Docs** | OT (Operational Transformation) | 작업 순서를 기반으로 실시간 동기화     | 고성능 협업, 낮은 지연 시간, 빠른 텍스트 기반 편집에 최적화 |
| **Figma**       | CRDT (Conflict-free Replicated Data Type) | 자동 병합, 충돌 없음                  | 도형/객체 기반 편집에 강함, 오프라인/온라인 동기화 모두 지원 |
| **Notion**      | Hybrid (Server merge + 클라이언트 병합) | 최종 커밋 기준 병합                    | 충돌보다 사용 편의성 중심, 변경 사항을 서버가 우선 관리     |
| **Github (Git)**| Version Control + Manual Merge | 사용자 수동 병합 (Pull Request, Merge) | 문서보다 코드나 변경 이력 중심, 충돌 시 diff 수동 해결 필요  |
| **Trello**      | Lock + Polling 방식             | 보통 마지막 저장자 기준 (낙관적)       | 충돌 가능성 낮고 실시간성 낮아 간단한 협업에 적합            |

### 시스템 선택 시 고려 사항

- **OT**: 실시간 커서 위치, 텍스트 병합 등 고속 협업에 적합
- **CRDT**: 분산 환경 + 오프라인 동기화가 필요할 때
- **Hybrid**: 사용자 편의 + 서버 병합 우선시할 때
- **Lock 기반**: 간단한 동시성 제어가 필요할 때
- **Git 기반**: 변경 이력 관리와 충돌 수동 조정이 중요한 경우

