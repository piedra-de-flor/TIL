# MySQL - ES 동기화 방법 정리

---

## 1. Full Reindex (전체 재색인)

### 개념
MySQL 전체 데이터를 정기적으로 조회하여 ES에 통째로 다시 색인(Bulk Insert)하는 방식.  
주로 주기적인 스케줄러 또는 수동 배치로 수행.

### 장점
- 구조 단순, 구현 쉬움
- 데이터 불일치가 있어도 재색인으로 복구 가능
- 초기 개발 또는 운영 중 긴급 복구에 유리

### 단점
- 데이터량 증가 시 성능 저하
- 불필요한 중복 색인 (변경 없는 데이터도 포함)
- 실시간 동기화 불가

### 추천 시점
- 초기 개발, 운영 전 색인 목적
- 데이터 규모가 작고 변경이 드문 경우
- 매일 새벽 정기 동기화로 충분한 경우

---

## 2. Dual Write (이중 저장)

### 개념
애플리케이션에서 MySQL 저장과 동시에 ES에도 데이터를 색인하는 구조.  
Transactional boundary 외부에서 처리되므로 완전한 일관성은 보장되지 않음.

### 장점
- 실시간 조회 가능
- 구조가 단순하고 구현 빠름
- Kafka 등 중간 인프라 필요 없음

### 단점
- MySQL과 ES의 저장이 분리됨 → 일부 실패 시 데이터 불일치 발생
- 롤백 어려움 (ES와 DB 중 하나만 성공하는 경우)

### 추천 시점
- 작은 규모의 서비스 또는 MVP
- 검색 정확성보다 검색 가능성이 중요한 경우
- 추후 Kafka or CDC 구조로 전환할 예정인 경우

---

## 3. Event Queue 기반 (Kafka 등)

### 개념
MySQL 저장 이후 이벤트 발행 (예: Kafka),  
Consumer가 해당 이벤트를 받아 ES에 색인하는 방식.  
실시간성과 복구성을 고려한 이벤트 기반 아키텍처.

### 장점
- 비동기 처리로 성능 영향 적음
- 장애 시 메시지 재처리 가능
- CDC 없이도 비슷한 효과 가능

### 단점
- Kafka/Redis 등 브로커 도입 필요
- 중복 소비, 메시지 유실 처리 필요
- 데이터 일관성 문제는 여전히 존재 가능

### 추천 시점
- 중간 규모 이상 서비스
- 비동기 처리 구조 도입 중
- 색인 실패 시 재처리, 유실 방지 등의 요구가 있는 경우

---

## 4. CDC (Change Data Capture)

### 개념
MySQL의 변경 로그(binlog)를 추적하여 DB 레벨의 모든 변경사항을 감지 → ES로 전송  
주로 Debezium + Kafka Connect 등의 도구 사용

### 장점
- 완전한 데이터 변경 감지 (INSERT, UPDATE, DELETE 모두 포함)
- DB 로직과 애플리케이션을 전혀 침범하지 않음
- 높은 실시간성과 정합성

### 단점
- 구성 복잡 (Kafka, Debezium, Connect 필요)
- 운영 난이도 ↑
- binlog 설정, 권한 구성 필요
- 외부 시스템 도입에 대한 러닝커브

### 추천 시점
- 대규모 트래픽 및 데이터 정합성이 중요한 경우
- 다수의 시스템과 연계되는 MSA 구조
- 실시간 분석, 감사(Audit) 등의 요구가 있는 경우

---

## 5. Trigger + Log Table 방식

### 개념
MySQL에 Trigger를 걸어 변경이 발생할 때마다 로그 테이블에 기록하고,  
해당 로그를 주기적으로 읽어 ES에 색인

### 장점
- 삭제, 수정 등도 감지 가능
- CDC보다 간단하게 변경 감지 가능
- MySQL만으로도 구성 가능

### 단점
- Trigger는 성능에 영향 줄 수 있음
- 로그 테이블 관리, 정리 필요
- 실시간성이 약함

### 추천 시점
- CDC는 과하지만, 삭제 추적은 필요한 경우
- MySQL 단독으로 변경 감지를 구현하고 싶은 경우
