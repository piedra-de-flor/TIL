# 숙소 검색에 Elasticsearch 도입 시 고려사항 정리

## 1. 도입 배경 및 목적

| 항목 | 설명 |
|------|------|
| 목적 | 사용자 친화적인 숙소 검색 UX 제공 |
| 기존 한계 | `LIKE`, `IN`, `=`, `AND` 기반 RDB 쿼리는 자연어 검색에 한계 |
| 기대 효과 | - Full-text 검색<br>- 자동완성<br>- 오타 허용<br>- 검색 결과 정렬 최적화 |

---

## 2. 주요 요구사항 (검색 기능)

| 기능 | 설명 |
|------|------|
| 키워드 검색 | "제주 호텔" → 숙소명, 태그, 설명 등에서 키워드 매칭 |
| 자연어 문장 처리 | "제주 바다 보이는 호텔" → 위치 + 뷰 + 숙소 타입 해석 |
| 자동완성 | "제주" 입력 시 "제주 라마다 호텔", "제주 오션뷰 리조트" 추천 |
| 오타 허용 | "보이느 호텔" → "보이는 호텔" 검색 결과 제공 |
| 우선순위 정렬 | 숙소명에 포함되면 높은 점수 부여 (Boost) |
| 복합 조건 필터 | 가격대, 숙소 타입, 평점, 지역 등으로 추가 필터링 가능 |

---

## 3. 기술적 고민 포인트

| 구분 | 고민 내용 |
|------|-----------|
| 검색 정확도 | 형태소 분석기 선택 (`nori`, `arirang`, 사용자 정의 등) |
| 성능 | 검색 응답 속도, 분석기 비용, 스케일업 시 노드 수 고려 |
| 데이터 동기화 | RDB ↔ ES 동기화 (CDC, 비동기 큐, Bulk API 등) |
| 색인 구조 | 어떤 필드를 `text`, 어떤 필드를 `keyword`로 처리할지 |
| 검색 품질 튜닝 | Boost 설정, Analyzer 튜닝, Synonym 추가 등 |
| 🛠운영 | ES 클러스터 운영, 색인 재빌드, 로그 추적 등 |

---

## 4. 구현 단계

### 4.1 새로운 숙소 도메인 모델 예시
```json
{
  "id": 123,
  "name": "제주 라마다 호텔",
  "lentPrice": 123,
   ...
   ...
  "description": "에메랄드빛 바다 전망, 공항 근처 위치",
  "location": "제주특별자치도 제주시",
  "type": "호텔",
  "tags": ["오션뷰", "바다", "호텔", "공항", "제주"]
}
```

## 4.2 Elasticsearch 매핑 구조

| 필드명 | 타입 | 설명 |
|--------|------|------|
| `name` | text | 숙소 이름. 형태소 분석기 적용 (검색 가중치 높음) |
| `description` | text | 숙소 설명 텍스트. 자유로운 검색 대상 |
| `tags` | text | 키워드 기반 검색용 태그 (ex: 바다, 오션뷰) |
| `location` | text | 지역명, 주소 (제주, 서귀포 등) |
| `type` | keyword | 숙소 타입 (호텔, 리조트, 게스트하우스 등) |
| `name_suggest` | completion | 자동완성 전용 필드 (prefix 기반 추천) |

> `text` 타입에는 analyzer가 적용되어 자연어 검색 가능  
> `keyword`는 정렬, 정확한 필터링에 사용  
> `completion`은 자동완성 구현에 필수

---

## 5. 검색 쿼리 전략

### 5.1 자연어 키워드 검색 (multi_match)

| 항목 | 설명 |
|------|------|
| 목적 | 사용자의 복합 문장을 여러 필드에 검색 |
| 방식 | `multi_match`로 `name`, `description`, `tags` 필드를 동시에 검색 |
| 가중치 | `name^3`, `tags^2` 등 중요도에 따라 부여 |

```json
{
  "query": {
    "multi_match": {
      "query": "제주 바다 보이는 호텔",
      "fields": ["name^3", "tags^2", "description"]
    }
  }
}
```

### 5.2 오타 허용 검색 (fuzzy match)

| 항목 | 설명 |
|------|------|
| 목적 | 사용자의 입력 실수를 허용 (예: '보이느' → '보이는') |
| 방식 | `match` 쿼리에 `fuzziness: AUTO` 옵션 설정 |
| 추천 상황 | 모바일 환경, 사용자 오입력 고려 시 유용 |

```json
{
  "query": {
    "match": {
      "name": {
        "query": "보이느 호텔",
        "fuzziness": "AUTO"
      }
    }
  }
}
```

### 5.3 자동완성 기능 (completion suggest)

| 항목 | 설명                                      |
| -- | --------------------------------------- |
| 목적 | 검색창에 입력하는 동안 추천 검색어 제공                  |
| 필드 | `name_suggest` 필드를 `completion` 타입으로 색인 |
| 옵션 | `prefix`, `fuzzy` 조합으로 실시간 추천 가능        |

```json
{
  "suggest": {
    "hotel-suggest": {
      "prefix": "제주",
      "completion": {
        "field": "name_suggest",
        "fuzzy": true
      }
    }
  }
}
```
## 6. 데이터 동기화 전략

| 방식               | 설명                                  | 장점                | 단점                  |
| ---------------- | ----------------------------------- | ----------------- | ------------------- |
| **Dual Write**   | RDB 저장 시 ES에도 동시 색인                 | 구현 간단, 빠른 적용      | 트랜잭션 분리됨, 실패 복구 어려움 |
| **Kafka 비동기 처리** | 저장 후 Kafka 이벤트 발행 → Consumer가 ES 색인 | 확장성 우수, 장애 복원 용이  | 구조 복잡, 실시간성 약간 낮음   |
| **Debezium CDC** | RDB binlog 기반 변경 감지 → ES 색인         | 정합성 보장, 시스템 분리 가능 | 세팅 복잡, 운영 난이도 ↑     |


## 7. 검색 품질 향상 전략

| 항목                        | 설명                   | 예시 / 전략                             |
| ------------------------- | -------------------- | ----------------------------------- |
| **형태소 분석기 설정**            | 한국어에 적합한 analyzer 선택 | `nori`, `seunjeon`, 사용자 정의          |
| **동의어 사전 설정**             | 유사 단어 매핑으로 검색 유연성 ↑  | `"바다"` ≈ `"오션"`, `"숙소"` ≈ `"호텔"`    |
| **Boost 전략**              | 검색 대상 필드별 가중치 차등 부여  | `name^3`, `tags^2`, `description^1` |
| **Function Score**        | 평점, 리뷰수 등을 스코어에 반영   | `score = text_score * 평점 * 리뷰보정값`   |
| **불용어 제거 / tokenizer 설정** | 조사, 접사 제거로 의미 단어만 추출 | `"제주의"` → `"제주"`                    |
| **검색 로그 기반 튜닝**           | 사용자 검색 패턴을 기반으로 개선   | 인기 검색어, 노출 우선순위 조정                  |
