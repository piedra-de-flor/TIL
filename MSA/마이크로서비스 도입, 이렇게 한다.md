# 📘 《마이크로서비스 도입, 이렇게 한다》 요약 (샘 뉴먼)

## 1장: 더도 덜도 아닌 딱 마이크로서비스
- **정의**: 독립적으로 배포 가능한, 비즈니스 도메인 기반의 작은 서비스들.
- **모놀리스와 비교**:
    - 모놀리스: 단순, 일관성 → 복잡성 증가 시 유지보수 어려움.
    - 마이크로서비스: 독립 배포, 유연함 → 분산 시스템의 복잡성 존재.
- **장점**:
    - 빠른 배포, 병렬 개발, 기술 다양성 허용.
- **단점**:
    - 통신 비용 증가, 데이터 일관성 문제, 운영 복잡성.
### 🔍 마이크로서비스란?

- **마이크로서비스 아키텍처(MSA)**는 하나의 응집도 높은 어플리케이션을 **작은 서비스들의 집합**으로 분할한 아키텍처 패턴입니다.
- 각 서비스는 **독립적으로 배포**, **개발**, **스케일링** 가능하며, **하나의 비즈니스 기능**에 집중합니다.
- 일반적으로 REST, gRPC, 메시지 브로커(Kafka 등)를 통해 통신합니다.

> ☝️ 핵심 철학: 시스템을 작게 쪼개어 *변화에 유연하고*, *빠르게 대응할 수 있도록* 만든다.

---

### ⚖️ 모놀리스와의 비교

| 항목 | 모놀리스 | 마이크로서비스 |
|------|----------|----------------|
| **구성** | 단일 코드베이스 | 독립 서비스들의 집합 |
| **배포** | 전체 앱 통합 배포 | 각 서비스 개별 배포 가능 |
| **개발 속도** | 초기 빠름, 규모 커지면 느려짐 | 병렬 개발 가능, 팀 단위로 확장 유리 |
| **장애 전파** | 전체 시스템 영향 | 격리로 인해 영향 최소화 가능 |
| **운영 복잡도** | 단순 | 인프라/운영 도구 많아져 복잡 |

---

### ✅ 마이크로서비스의 장점

1. **독립 배포**
  - 각 서비스는 다른 서비스에 영향 없이 배포 가능.
  - CI/CD 파이프라인을 서비스 단위로 분리 가능.

2. **기술 이질성 허용**
  - Java, Python, Node.js 등 다양한 언어 및 기술 스택 사용 가능 (단, 관리 난이도는 증가).

3. **병렬 개발 가속화**
  - 팀 간 의존도 최소화 → 빠른 기능 개발, 독립적 롤백 가능.

4. **확장성**
  - 특정 서비스만 별도로 스케일 아웃 가능 (예: 결제만 10배 확장 등).

5. **장애 격리 및 회복성**
  - 개별 서비스 실패가 전체 장애로 확산되지 않도록 격리할 수 있음 (Circuit Breaker 패턴 등 활용 가능).

---

### ❌ 마이크로서비스의 단점

1. **운영 복잡도 증가**
  - 서비스 수 증가 → 모니터링, 로깅, 배포 관리가 복잡해짐.
  - Kubernetes, 서비스 메시(Istio, Linkerd) 같은 도구 필요.

2. **분산 시스템의 본질적인 문제**
  - 네트워크 장애, 지연, 부분 실패 등 고려해야 함.
  - 트랜잭션 일관성 보장이 어려움 → eventual consistency 설계 필요.

3. **서비스 간 통신 부담**
  - API 또는 메시징 기반의 통신 필요 → Latency, 버전 관리, 인증 문제 발생 가능.

4. **테스트 및 디버깅 난이도**
  - 통합 테스트가 어려워지고, 전체 흐름 파악이 힘들어짐 → E2E 테스트 체계가 중요.

---

### 🧠 적용 전 반드시 자문할 질문들

- “현재 우리 시스템이 **과연** 마이크로서비스를 필요로 하는가?”
- “분산 시스템을 운영할 만한 **조직 역량**과 **DevOps 문화**가 있는가?”
- “기술보다 중요한 건 조직의 **협업 방식**과 **경계 설계**다.”

> ⚠️ 마이크로서비스는 만능 해법이 아니라, 특정 조건에서만 빛을 발하는 전략입니다.

---

### 🏁 요약

- 마이크로서비스는 **단순히 '작게 나눈 것'이 아닌**, 설계, 운영, 문화 전체에 영향을 미치는 **아키텍처 전환 전략**입니다.
- 도입 전에는 **조직 문화, 개발 프로세스, 운영 능력**이 함께 진화할 수 있는 준비가 되어 있어야 합니다.
- 가장 중요한 건 *작은 단위의 독립성과 변경 용이성*을 확보하는 것.


## 2장: 마이그레이션 계획하기
- **도입 전 고려사항**:
    - 현재 문제를 마이크로서비스가 해결 가능한가?
    - 조직/문화/역량이 준비되어 있는가?
- **도입 전략**:
    - 점진적 접근이 핵심 (Big Bang 방식은 위험).
- **조직 구조 영향**:
    - 콘웨이 법칙: 조직 구조가 시스템 구조를 결정한다.

## 3장: 모놀리스 분할
- **서비스 분할 기준**:
    - 비즈니스 도메인 단위 또는 Bounded Context.
- **좋은 경계 설정법**:
    - 낮은 결합도, 높은 응집도.
- **분할 전략**:
    - UI → API → 데이터베이스 순으로 점진적 분리.

## 4장: 데이터베이스 분해
- **서비스별 데이터 소유**:
    - 각 서비스는 자기 데이터베이스를 소유해야 함.
- **데이터 공유 방법**:
    - DB 직접 접근 금지, API 또는 이벤트로 통신.
- **데이터 일관성 처리**:
    - SAGA 패턴, 이벤트 소싱, eventual consistency 고려.

## 5장: 도입 시 문제와 해법
- **문제들**:
    - 서비스 간 장애 전파, 배포 복잡도, 관찰성 부족.
- **해법**:
    - 모니터링 및 로깅 도입 (예: ELK, Prometheus),
    - 자동화된 배포 파이프라인,
    - Circuit Breaker, Retry, Timeout 등 장애 복원 설계.

---

## ✅ 핵심 통찰 요약

- **모놀리스도 나쁜 건 아님**: 단순한 서비스에는 여전히 효과적.
- **마이크로서비스 도입은 기술+조직 변화**가 필요.
- **빠르지 않아도 된다**: 점진적인 리팩터링이 성공의 핵심.
- **관찰성과 테스트 자동화는 필수**: 복잡성을 감당할 기반 필요.

---

<<<<<<< HEAD
📚 로깅 시스템 및 MSA 트레이싱 학습/고민 정리
🔍 1. Elasticsearch(ES) 모니터링 툴
Kibana: 기본 시각화 도구. 검색, 대시보드, 에러 로그 필터링에 적합

Grafana: Elasticsearch를 데이터 소스로 연결하여 실시간 성능 모니터링 가능

Prometheus + Exporter: elasticsearch_exporter를 통해 지표 수집 후 알림 설정 가능

Elastic Stack 자체 모니터링: X-Pack 모듈 통해 노드 상태, 인덱스 상태, 큐 상태 추적

💾 2. InfluxDB를 로그용으로 사용하는 건 어떨까?
❌ 일반적으로는 부적절함

InfluxDB는 시계열 데이터에 최적화되어 있으며, 로그 같은 비정형 데이터 처리엔 비효율적

✅ 활용 가능 케이스

로그의 일부에서 수치 기반 메트릭을 뽑아 시계열로 처리하는 경우 (예: 응답시간, 처리 건수 등)

Prometheus 대체 or 함께 사용할 때

🧵 3. MDC (Mapped Diagnostic Context) 심화
✅ 개념
로그에 부가적인 context 정보(traceId, 사용자 email 등)를 포함시키기 위한 ThreadLocal 기반 저장소

로그 포맷에 [%X{traceId}] 등의 방식으로 삽입 가능

🔄 소멸 시기
Thread 단위 저장이기 때문에 요청 완료 후 명시적으로 MDC.clear() 해야 함

try-finally 안에서 clear 필수

java
Copy
Edit
try {
MDC.put("traceId", uuid);
...
} finally {
MDC.clear();
}
🔧 4. 비동기 처리 시 MDC 문제
MDC는 기본적으로 ThreadLocal 기반 → 새로운 스레드(executor, @Async 등)로 넘어가면 context 손실

해결 방법:

MDC Context를 복사해 넘겨주는 MdcTaskDecorator 구현

Executor나 @Async Bean 등록 시 taskDecorator 설정

Project Reactor 기반일 경우 Context 사용 필요

🔗 5. MSA에서 trace 로그 전파하기
핵심 전략
최초 요청 지점에서 traceId 생성

이후 HTTP 호출마다 X-Trace-Id header에 담아 전달

모든 로그에 MDC.put("traceId", ...) 적용

Feign, WebClient, RestTemplate 등에 공통 인터셉터 적용 필수

🪵 6. Kibana에서 로그가 안보일 때, 에러 발생 시 순서
애플리케이션 로그 파일에 출력 여부 확인 (Logback 설정)

Logstash 입력 파이프라인 확인 (path, codec, start_position)

Logstash 출력 설정 확인 (Elasticsearch 연결, 인증, index 이름)

Elasticsearch 인덱스 생성 여부 및 mapping 확인

Kibana에서 인덱스 패턴 등록 여부 확인

Elasticsearch Logstash 로그의 오류 로그 분석

🐢 7. 비동기 or 배치 로그 누락 시 원인
❌ MDC context 손실로 인한 로그 필드 누락 (ex. traceId 없음)

❌ 로그 flush가 되기 전에 애플리케이션 종료

❌ 파일 롤링/권한 문제로 Logstash가 새 파일을 못읽음

❌ 로그 파서(JSON 포맷 등)가 오류를 내고 있음

⚠️ 8. 로그 과다로 인해 Logstash/ES 장애 발생 시 대응 전략
📌 증상
Logstash pipeline backlog 증가

Elasticsearch 인덱스 write latency 급증

Kibana에서 로그 미표시 or 대기 시간 증가

🛠 체크리스트
Logstash 큐 모니터링 (queue.type, dead_letter_queue.enable)

Elasticsearch 디스크 사용량, JVM Heap, GC 확인

로그 양 조절 (샘플링, 로그레벨 조정, 필터)

인덱스 rollover, ILM 정책 도입

로그 전송 경로에 gzip 또는 batch 처리 적용



=======
2025.06.07 결혼식 이슈로 하루 미루기
>>>>>>> bd6585d4d0b06fdaed2d49dcf2add6c8deb17a4c
