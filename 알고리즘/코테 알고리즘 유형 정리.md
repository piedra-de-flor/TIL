# ì½”ë”©í…ŒìŠ¤íŠ¸ ë¬¸ì œ ìœ í˜•ë³„ ì•Œê³ ë¦¬ì¦˜ ì •ë¦¬

## ğŸ“Œ ê·¸ë˜í”„ íƒìƒ‰
| ìœ í˜• | ì•Œê³ ë¦¬ì¦˜ | ì„¤ëª… |
|------|---------|------|
| ì™„ì „íƒìƒ‰ | **DFS** | ëª¨ë“  ê²½ë¡œë¥¼ íƒìƒ‰í•´ì•¼ í•  ë•Œ (ë°±íŠ¸ë˜í‚¹ í™œìš© ê°€ëŠ¥) |
| ìµœë‹¨ê±°ë¦¬(ê°€ì¤‘ì¹˜ 1) | **BFS** | ìµœë‹¨ ê²½ë¡œ íƒìƒ‰ (ê°€ì¤‘ì¹˜ê°€ ëª¨ë‘ 1ì¸ ê²½ìš°) |
| ìµœë‹¨ê±°ë¦¬(ê°€ì¤‘ì¹˜ O) | **ë‹¤ìµìŠ¤íŠ¸ë¼** | í•œ ì§€ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì§€ì ê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ íƒìƒ‰ |
| ëª¨ë“  ì§€ì  ê°„ ìµœë‹¨ê±°ë¦¬ | **í”Œë¡œì´ë“œ-ì›Œì…œ** | ëª¨ë“  ì •ì  ê°„ ìµœë‹¨ê±°ë¦¬ íƒìƒ‰ (O(NÂ³)) |
| ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ | **í¬ë£¨ìŠ¤ì¹¼, í”„ë¦¼** | ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ë…¸ë“œë¥¼ ì—°ê²° |

### âœ… DFS (ê¹Šì´ ìš°ì„  íƒìƒ‰)
```java
import java.util.*;

public class DFS {
    static boolean[] visited;
    static List<Integer>[] graph;
    
    public static void dfs(int node) {
        visited[node] = true;
        System.out.print(node + " ");
        for (int next : graph[node]) {
            if (!visited[next]) {
                dfs(next);
            }
        }
    }
}
```

### âœ… BFS (ë„ˆë¹„ ìš°ì„  íƒìƒ‰)
```java
import java.util.*;

public class BFS {
    static boolean[] visited;
    static List<Integer>[] graph;
    
    public static void bfs(int start) {
        Queue<Integer> queue = new LinkedList<>();
        queue.add(start);
        visited[start] = true;
        
        while (!queue.isEmpty()) {
            int node = queue.poll();
            System.out.print(node + " ");
            for (int next : graph[node]) {
                if (!visited[next]) {
                    queue.add(next);
                    visited[next] = true;
                }
            }
        }
    }
}
```

---

## ğŸ“Œ ë™ì  ê³„íšë²• (DP)
| ìœ í˜• | ì•Œê³ ë¦¬ì¦˜ | ì„¤ëª… |
|------|---------|------|
| ë©”ëª¨ì´ì œì´ì…˜ | **DP (í”¼ë³´ë‚˜ì¹˜)** | ë°˜ë³µë˜ëŠ” ì—°ì‚°ì„ ì¤„ì´ê¸° ìœ„í•œ ìµœì í™” |

### âœ… DP (ë™ì  ê³„íšë²• - í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´)
```java
public class DP {
    static int[] dp = new int[100];
    
    public static int fibonacci(int n) {
        if (n <= 1) return n;
        if (dp[n] != 0) return dp[n];
        return dp[n] = fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```

---

## ğŸ“Œ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜
| ìœ í˜• | ì•Œê³ ë¦¬ì¦˜ | ì„¤ëª… |
|------|---------|------|
| ë‹¨ì¼ ì¶œë°œì  ìµœë‹¨ê±°ë¦¬ | **ë‹¤ìµìŠ¤íŠ¸ë¼** | í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ê¹Œì§€ ìµœë‹¨ê±°ë¦¬ |

### âœ… ë‹¤ìµìŠ¤íŠ¸ë¼ (ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜)
```java
import java.util.*;

public class Dijkstra {
    static class Node implements Comparable<Node> {
        int index, cost;
        public Node(int index, int cost) {
            this.index = index;
            this.cost = cost;
        }
        public int compareTo(Node o) {
            return Integer.compare(this.cost, o.cost);
        }
    }
    
    static void dijkstra(int start, List<Node>[] graph, int[] dist) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(start, 0));
        dist[start] = 0;
        
        while (!pq.isEmpty()) {
            Node now = pq.poll();
            if (now.cost > dist[now.index]) continue;
            
            for (Node next : graph[now.index]) {
                int newDist = dist[now.index] + next.cost;
                if (newDist < dist[next.index]) {
                    dist[next.index] = newDist;
                    pq.add(new Node(next.index, newDist));
                }
            }
        }
    }
}
```

---

## ğŸ“Œ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (MST)
| ìœ í˜• | ì•Œê³ ë¦¬ì¦˜ | ì„¤ëª… |
|------|---------|------|
| ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ | **í¬ë£¨ìŠ¤ì¹¼** | ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ëª¨ë“  ì •ì ì„ ì—°ê²° |

### âœ… í¬ë£¨ìŠ¤ì¹¼ (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)
```java
import java.util.*;

public class Kruskal {
    static class Edge implements Comparable<Edge> {
        int u, v, weight;
        public Edge(int u, int v, int weight) {
            this.u = u;
            this.v = v;
            this.weight = weight;
        }
        public int compareTo(Edge o) {
            return Integer.compare(this.weight, o.weight);
        }
    }
    
    static int find(int[] parent, int x) {
        if (parent[x] != x) parent[x] = find(parent, parent[x]);
        return parent[x];
    }
    
    static void union(int[] parent, int a, int b) {
        int rootA = find(parent, a);
        int rootB = find(parent, b);
        if (rootA != rootB) parent[rootB] = rootA;
    }
    
    static int kruskal(List<Edge> edges, int n) {
        Collections.sort(edges);
        int[] parent = new int[n + 1];
        for (int i = 1; i <= n; i++) parent[i] = i;
        
        int totalWeight = 0;
        for (Edge edge : edges) {
            if (find(parent, edge.u) != find(parent, edge.v)) {
                union(parent, edge.u, edge.v);
                totalWeight += edge.weight;
            }
        }
        return totalWeight;
    }
}
```

---
ê° ë¬¸ì œ ìœ í˜•ë³„ë¡œ ì ì ˆí•œ ì•Œê³ ë¦¬ì¦˜ì„ ì„ íƒí•˜ë©´, ìµœì ì˜ í’€ì´ë¥¼ ë¹ ë¥´ê²Œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸš€

