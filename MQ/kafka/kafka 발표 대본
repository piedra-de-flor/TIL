1
현대 비즈니스 환경에서는 매초마다 엄청난 양의 데이터가 생성되고 있습니다.
특히 금융이나 전자상거래, IoT 분야에서는 실시간 데이터 처리 능력이 비즈니스 경쟁력과 직결됩니다.

이러한 대용량 데이터를 효율적으로 처리하고 대규모 데이터 처리와 실시간 스트리밍이 중요해진 현대 기업 환경에서
아파치의 카프카는 핵심 인프라로 자리잡았습니다.
이번 발표에서는 카프카의 성능을 향상시키기 위한 실질적인 방안들을 카프카의 구성요소별로 말해보고자 합니다.


2
카프카의 성능 개선 및 최적화를 알아보기에 앞서서 먼저
성능 개선 및 최적화를 할 때 어떤 점들을 주로 봐야할지, 어떻게 개선해야할지 먼저 말해보자면
성능 개선이나 최적화를 할 때는 주로 Throughput, Latency, Durability, Availability 이 4가지를 확인합니다.
각각은 처리율 혹은 처리량, 지연시간, 내구성, 가용성을 뜻하는데요

처리율은 단위 시간당 처리할 수 있는 데이터의 양을 뜻하고
지연시간은 말 그대로 얼마의 시간이 걸리는지,
내구성은 데이터가 손실되지 않고 안전하게 잘 저장되는지,
가용성은 시스템이 지속적으로 서비스를 제공할 수 있는지를 뜻합니다.

이번 발표에서도 이 4가지를 기준으로 삼아 방법마다의 Trade off 관계를 설명해줄거고
트레이드 오프 관계를 보고 성능 개선 요구사항에 맞춰서 적절한 성능 개선을 해야한다는 것을 알아두시고


3
카프카의 성능을 최적화하기 위해서는 먼저 그 아키텍처를 정확히 이해해야 합니다.
위쪽의 사진처럼 카프카는 프로듀서, 브로커, 컨슈머(Consumer)로 구성된 분산 메시징 시스템으로,
기본적으로 Pub/Sub 방식으로 구성되어 있습니다.

아래 사진은 카프카의 내부 구조인데요, 이번 발표의 주제가 카프카의 동작과정이나, 특징, 내부구조 이런게
아니기 때문에 간단하게만 알아보자면
카프카 브로커를 관리하는 카프카 클러스터가 있고 그안의
브로커는 카프카의 핵심 서버로, 메시지를 저장하고 전달하는 역할을 합니다.
브로커 안에 있는 토픽은 데이터를 저장하는 기준 혹은 데이터 스트림의 카테고리이며,
각 토픽은 여러 파티션으로 나뉘어 분산 저장됩니다.

다시 말해, 카프카는 여러대의 브로커로 구성되고 그 브로커는 여러개의 토픽, 토픽은 여러개의 파티션으로 분산되어
구성되어있습니다.
이러한 분산 구조는 카프카의 확장성과 고가용성을 보장하지만,
동시에 성능 최적화의 복잡성을 증가시키는 요인이 됩니다.

카프카의 내부 구조 설명은 이정도만 하고,
이제부터 성능 개선의 방법들을 알아볼건데, 저희는 프로듀서, 브로커, 컨슈머 이 3 파트로 나눠서
별도의 외부 설정이 아닌 내부 설정들로 가능한 성능 개선의 방법을 알아보겠습니다.


4
먼저 데이터를 카프카로 전송하는 클라이언트인 프로듀서 입니다.
크게 본 프로듀서에서 가능한 성능 개선 방법은 2가지로 메세지를 효율적으로 보내거나
메세지를 정확하게 보내는 것입니다.

먼저 효율적으로 보내는 방법입니다.
메세지를 프로듀서가 효율적으로 보내기 위해서는 배치 사이즈를 증가시키거나 linger를 증가 시킬 수 있는데,
먼저 배치 사이즈 증가 입니다.
이 배치 사이즈는 프로듀서가 브로커에 한 번에 보내는 메세지, 즉 데이터의 양을 뜻하는데요
이 배치사이즈를 증가시키면, 프로듀서 측에서는 한번의 요청에 많은 데이터를 전송할 수 있게 되어
네트워크의 오버헤드가 감소하고, 데이터를 압축시킬 경우엔 효율이 좋아져서 처리율이 좋아지고

브로커 측에서 보면 처리해야 할 요청을 수가 줄어드니 브로커 간의 컨텍스트 스위칭이 줄어들어 성능이 향상되어 처리율이 증가합니다.

하지만 배치 사이즈가 늘어나게 되면 메세지를 그만큼 모아서 보내기 때문에, 한 배치를 채우기 위해 더 많은 메세지를
기다리게 됩니다.
즉 프로듀서에서 브로커로 전달되기 전까지 내부 버퍼에 너무 오래 머물게 되면서 Latency가 증가할 수 있고,
그만큼 프로듀서에서 많은 메모리를 사용하게 된다는 단점이 있습니다.


그 다음은 linger 증가인데요
linger는 프로듀서가 브로커에게 메세지를 전송하는 주기를 뜻합니다.
이 linger는 배치 사이즈와도 연관이 있는데, 프로듀서에 설정된 linger 의 시간이 되면
배치가 가득차지 않아도 데이터를 브로커에게 전송하게 됩니다.
이러한 linger를 증가시킨다면, 배치 사이즈를 증가시켰을 때와 마찬가지로 네트워크 오버헤드 감소와
데이터 압출 효율의 증가로 처리율이 증가합니다.

하지만 메세지를 전송하는 주기를 크게 잡는다면 자연스럽게 latency 는 증가하게 된다는 단점이 있습니다.
이렇게 프로듀서가 브로커에게 메세지를 효율적으로 보내는 방법 2가지를 살펴봤는데,
이 배치 사이즈와 linger의 크기는 서로 연관이 있기 때문에 잘 조율해서 사용할 필요가 있습니다.

다음으로는 메세지를 정확하게 보내서 Durability를 높이는 방법입니다.
acks 관리와 retries관리 2가지 방법을 살펴볼건데, 먼저 acks는 메세지 확인 처리를 위한 복제본의 수를 뜻합니다.
프로듀서는 메세지가 잘 전송되었는지 확인하기 위해 브로커에게서 확인 응답을 받는데,
브로커는 하나의 데이터가 들어오면 이를 복제하여 분산 저장하고, 각각의 브로커에서 저장 완료 응답을 주는 방식입니다.

그래서 브로커가 메세지를 정확하게 받았다는 것은 정해진 수만큼의 데이터 복제까지 끝냈다는 것을 의미하는데,
프로듀서측에서는 몇개의 데이터 복제 완료 응답을 받았을 때, 메세지가 정확하게 전송되었는지 acks 관리를 통해
조절할 수 있습니다.

acks는 가장 작게 0부터 all 까지 설정이 가능한데, 크게 잡는다면 데이터의 복제가 더욱 완벽하게 이루어졌음을 확인하므로
Durability가 증가하지만, 그만큼 메세지 전송 완료 응답이 늦게 처리되면서 Latency가 증가하게 되고,
acks를 작게 설정한다면 그 반대의 상황이 발생합니다.

따라서 이 acks는 요구사항에 맞게 조절해야하는데, 현재는 메세지를 정확하게 보내는 것이 목적이기 때문에 acks를 증가
시키는 것이 올바른 성능 개선 방안이죠.

두번째는 retries 증가 입니다.
설정값인 retries에서도 바로 알 수 있다시피, 메세지의 전송 실패시 재시도 횟수를 증가시키는 것입니다.
따라서 장애 발생이나, 네트워크 오류로 인한 메세지 전송 실패시에도 재시도의 횟수를 증가시켜, 정확하게 메세지를 보내도록 할 수 있지만, 그만큼 더 많은 로직이 프로듀서측에서 작동되어야 하기 때문에, 메세지 전송 실패가 빈번한 상황에서는
프로듀서측의 부하가 그만큼 커질 수 있다는 단점이 있습니다.


5
이번에는 브로커 측면서의 성능 개선 및 최적화 방법을 알아볼건데,
브로커는 카프카의 핵심이라고 할 수 있는 파트로 메세지의 전달과 처리, 저장등 메세지 큐의 역할을 하는 만큼
성능이 중요한 부분입니다.

먼저 브로커의 처리율과 지연시간을 향상시킬 수 있는 방법들에는 스레드 수의 증가, log segment의 크기 증가,
ISR 튜닝중 복제 제한 시간 감소, log flush interval 증가가 있습니다.

스레드 수 증가부터 보자면, 브로커는 각각이 하나의 서버로 작동되고 데이터들을 메모리와 디스크에 저장하게 됩니다.
따라서 요청을 처리하는 네트워크 요청 처리 스레드와 디스크 I/O 처리 스레드의 수를 증가시키면
처리율과 지연시간이 늘어납니다. 하지만 많은 스레드를 관리해야하는 만큼 CPU 사용량과 스레드 관리 비용이 증가할 수 있죠.

그 다음은 로그 세그먼트 크기 증가입니다.
로그 세그먼트란, 브로커가 데이터를 디스크에 저장하는 데이터의 단위 크기라고 할 수 있는데요
브로커는 데이터가 들어오면 로그 세그먼트의 크기가 가득 찰 때 까지 메모리에 저장하고 있다가 로그 세그먼트가
가득 차게될 때, 디스크에 쓰기 작업을 통해 영구 저장 시키는 방식입니다.
또한 저장공간을 효율적으로 관리하기 위해 오래된 데이터를 삭제시키는 기능이 존재하는데,
이 로그 세그먼트의 크기를 증가 시킨다면 디스크 I/O 처리가 줄어들면서 처리율과 지연시간이 늘어나지만

그만큼 예전의 데이터와 최신의 데이터를 한번에 디스크에 저장하기 때문에, 삭제되어야 할 오래된 데이터들 또한
디스크에 쓰여진 시간에 맞춰서 더 오래 살아남게 되어 저장공간이 비효율적으로 사용될 가능성이 있습니다.


세번째로는 ISR 튜닝중 복제 제한 시간을 감소시키는 방법인데요
ISR이란 In-Sync-Replica의 약어로 동기화된 복제본의 집단이라는 뜻입니다.
앞서 설명드렸다 시피 카프카는 데이터를 받으면 고가용성을 위해 여러 브로커에 데이터를 복제시켜서 저장시킵니다.
이 때, 데이터를 처음 받는 리더 역할을 하는 파티션과 리더의 데이터를 복제하는 팔로워 파티션이 존재하게 되는데,
이 복제 제한 시간 감소는 팔로워 파티션이 리더 파티션의 데이터를 복제하는 시간의 제한을 감소시킨다는 의미입니다.
복제 제한 시간동안 복제를 하지 못한 팔로워 파티션은 ISR에서 빠지게 되고, Out-of-ISR이라는 뜻의 OSR로 상태가 변화하게 됩니다.

ISR에서 제외된 팔로워는 데이터의 복제를 멈추지는 않지만, ISR에서는 빠지게 되며 일정 시간이 지나면 다시 ISR에 포함될 수 있습니다.

이러한 복제 제한 시간을 감소시킨다면 이슈로 인해 복제가 느린 팔로워는 빠르게 버려서 처리 속도를 높혀주기 때문에
처리율과 지연시간이 향상되지만, 그만큼 데이터의 복제 제한 시간이 느린 팔로워들이 모두 ISR에서 제외되므로
가용성이 감소합니다.

마지막으로는 로그 플러시 인터벌을 증가시키는 방법인데, 로그 플러시 인터벌은 데이터를 디스크에 저장하는 주기입니다.
앞서 설명한 로그 세그먼트와 밀접한 관계가 있는 설정값으로, 이 로그 플러시 인터벌 시간이 되면 로그 세그먼트가
다 채워지지 않더라도 디스크에 쓰기 작업을 진행합니다.

이 로그 플러시 인터벌 또한 디스크 I/O 작업의 주기이기 때문에 시간을 늘리면 디스크 I/O 작업이 줄어들어 전체적인 성능이 증가하지만, 메모리에 데이터를 저장하고있는 시간이 길어지기 때문에 그만큼 데이터의 안전성인 내구도 Durability가 감소할 수 있습니다.


6
다음으로 볼 것은 브로커의 내구성과 가용성을 향상시키는 방법입니다.
브로커의 Durability 내구성을 향상시키는 방법은 SSD를 사용하거나 방금 말한 로그 플러시 인터벌을 감소시키는 방법이 있습니다.
브로커는 직접적으로 데이터를 저장하는 역할을 하기 때문에 Durability를 향상시키기 위해서는 저장공간인 디스크를
HDD에서 더 성능이 좋은 SSD로 변경할 수 있지만, 이는 SSD의 비싼 비용이 문제가 될 수 있으며

로그 플러시 인터벌의 감소는 아까 말했다시피 증가시키면 처리율과 지연속도 향상되지만 내구성 감소,
인터벌 시간을 감소시키면 처리율은 감소하고 지연시간은 증가하지만, 데이터를 그만큼 자주 영구저장하기 때문에
Durability가 향상됩니다.

Availability 가용성을 향상시키는 방법을 알아볼건데, 제가 알려드릴 방법은 ISR 튜닝중 복제본 replica의 수를 증가시키는 것입니다.
알다시피 브로커는 고가용성을 위해 데이터를 여러 브로커에 나눠서 분산 저장하는 방식을 사용하는데,
이때 몇개의 데이터 복제본을 둘 것인지 설정이 가능합니다.

replica의 수를 증가시킨다면 장애가 나더라도 대체할 수 있는 브로커가 많기 때문에 가용성이 향상되지만
그만큼 복제가 많이 처리되어야 하기 때문에 지연시간은 증가합니다.



7
마지막으로 컨슈머의 성능 개선 및 최적화 방법입니다.
컨슈머는 메세지를 보내는 클라이언트인 프로듀서의 반대로 메세지를 구독하여 받아보는 Subscriber의 역할입니다.
따라서 프로듀서와 유사하게 메세지를 효율적으로 읽거나 메세지를 정확하게 가져오는 방식의 성능 개선이 가능한데

프로듀서와 개선 방안이 유사합니다.
메세지를 효율적으로 읽기 위해 데이터를 한번에 많이 가져오도록 fetch 사이즈를 증가시키거나 fetch 주기를 증가시켜
한번에 많은 메세지를 들고 오도록 하여 처리율을 증가시킬 수 있고,

메세지를 정확하게 받기 위해 세션 타임 아웃을 증가 시킬 수 있습니다.
세션 타임 아웃은 컨슈머가 브로커의 파티션으로부터 데이터를 받기위해 연결한 세션의 타임아웃을 의미하는데
이를 증가시키면 데이터가 전송이 느리더라도 데이터 fetch를 보장할 수 있고, 브로커의 장애 감지를 정확하게 할 수 있지만, 그만큼 느린 세션에 대해서도 오래 대기하기 때문에, 처리율은 감소할 수 있습니다.


8
이렇게 카프카의 주요 구성 요소인 프로듀서, 브로커, 컨슈머로 나누어서 각각의 설정 가능한 옵션들 안에서
성능 개선 및 최적화 방법을 알아보았는데, 이 외에도 커널을 튜닝하거나, 카프카의 브로커가 기본적으로 JVM으로 작동
하기 때문에 JVM, GC 튜닝을 통해서도 성능 개선이 가능하며, 네트워크 자체의 성능을 높히는 것도 하나의 방법으로
작용할 수 있습니다.

또한 JVM으로 작동하는 카프카는 JMX 라는 성능 지표를 제공하기 때문에 프로메테우스와 그라파나를 통해
브로커의 메세지 처리량이나 컨슈머 지연, 디스크 사용률, 네트워크 처리량, CPU 사용률 등을 모니터링을 하여, 적절한 성능 개선 요구사항을 정립하는 것이 중요합니다.


