[CQRS와 이벤트소싱 1_merged.pdf](..%2F..%2F..%2F..%2F..%2FDownloads%2FCQRS%BF%CD%20%C0%CC%BA%A5%C6%AE%BC%D2%BD%CC%201_merged.pdf)

1.

안녕하세요, 이번 발표를 하게 된 최영우 입니다.

이번 발표는 CQRS와 이벤트 소싱, 기술이 아닌 전략으로써의 접근에 대해서 말해보려고 합니다.

처음에는 실무를 중점적으로 어떤 고민을 하는지에 대해 발표를 진행하려 했는데,

생각보다 시간이 많이 부족할거 같아 이번 발표에서는

CQRS와 이벤트 소싱이 뭔지, 어떤 식으로 사용이 되는지만 이해하고 가셨으면 합니다.

2.

본격적인 발표에 앞서 발표의 순서 먼저 말씀드리겠습니다.

먼저 CQRS와 이벤트 소싱에 대한 개념에 대해 소개하고, 우리가 이걸 왜 알아야 하는지에 대한

내용으로 첫번째 컨텐츠를 준비했고요.

두번째로 CQRS와 이벤트 소싱을 함께 사용하는 구조, 실제 적용 사례를 통해

해당 기술을 언제, 어떻게 사용하는지 알아본 다음

마지막으로 실무에서의 관점 및 도입후 해야할 것들과 적용전 판단 기준, 마무리 멘트로 발표를 준비했습니다.

3.

먼저 첫번째 챕터 CQRS와 이벤트 소싱에 대한 개념부터 알아보겠습니다.

4.

먼저 CQRS에 대해서 알아볼건데요, CQRS를 알기 위해서 어떤 배경에서 CQRS가 필요해졌는지부터

보겠습니다.

이 그림은 전통적인 CRUD 구조입니다.

컨트롤러에서 요청을 받으면 해당 도메인에 맞는 서비스와 도메인을 거쳐 하나의 DB에서 CRUD를

모두 처리하는 방식이죠.

하지만 이러한 구조는 요구사항 혹은 도메인이 복잡해지면 복잡해 질수록 유지보수가 굉장히 어려워지며,

책임이 불명확해지면서 SRP를 지키지 못할 수도 있다는 명확한 한계점이 존재합니다.

5.

코드로 예시를 들어보자면, 옆에 Order라는 주문 도메인이 존재한다고 가정해봅시다.

해당 주문 도메인은 주문 상태, 물건 리스트, 주문자의 정보를 필드로 가지고 있고,

주문 상태를 변경하는 approve 메서드와 주문 요약을 return라는 getOrderSummary 메서드가 있습니다.

여기서 approve 메서드는 데이터의 상태를 변경시키는 비지니스 로직 메서드라고 볼 수 있고,

getOrderSummary는 UI 측면에서 필요한 데이터를 포멧에 맞춰 return하는 조회용 로직이라 볼 수 있습니다.

현재처럼 도메인 자체가 복잡하지 않다면, 현재의 구조도 아무런 문제가 없습니다.

유지보수하기 전혀 어렵지 않은 엔티티지만, 만약 요구사항이 늘어난다면?

주문 도메인에, 등급이라던지, 배송 가능 지역 검증이라던지 등등 여러 요구사항이 새로이 들어온다면

그에 맞춰 Order 엔티티의 필드도 늘어나고, 검증 메서드 또한 늘어나야 합니다.

그런데 여기에 여러 서비스에서 각자 필요로 하는 조회 메서드까지 추가가 된다면

Order 엔티티는 분명 수십개의 getter, if문, for문등으로 뒤덮힌 괴물 엔티티가 될 것입니다.

6.

이러한 전통적 CRUD 구조는 유지보수의 어려움 및 SRP 위배 뿐 아니라, 조회 성능에서도 문제가 발생합니다.

예를 들어 유저가 앱에서 자신의 최근 5개 주문만 요약 형식으로 보고 싶다는 요구사항이 새로 들어왔을 때,

서비스 레이어에서 getRecentOrders라는 메서드를 만들어서 DB에서 JPA를 통해 조회를 하게 된다면,

이미 괴물 엔티티가 된 상황에서는 오른쪽과 같이 여러 JOIN 연산이 들어가게 되면서 조회의 성능이 떨어지게됩니다.

유저는 그저 최근 5개의 주문 정보만 요약식으로 보고자 했을 뿐인데, DB 쿼리가 도메인이 복잡해짐에 따라 함께 복잡해지면서 조회 성능이 저하되는 것이죠.

7.

그래서 도메인이 복잡해질 때, 이러한 문제점들을 해결하기 위해 나온게 CQRS 패턴입니다.

CQRS는 command query responsibility segregation의 약어로 명령 command와 조회 Query의 책임을

분리시키는 아키텍처 패턴입니다.

앞서 보았던 전통 CRUD 방식은 하나의 DB 하나의 서비스, 하나의 도메인을 가지고 모든 CRUD를 처리했지만

CQRS 패턴에서는 데이터의 상태를 바꾸는 Command와 데이터를 조회하는 Query로 나누어서 각자 처리를 합니다.

간단하게 그림을 설명해드리자면, 데이터의 생성, 수정, 삭제와 같은 쓰기 요청이 오면 controller가 command 전용 서비스를 호출합니다.

그러면 command 전용 도메인 모델을 생성하여, command 전용 DB에 저장을 시킨 뒤,

해당 쓰기 작업에 맞게 Query 전용 DB에 데이터 동기화를 시켜주고

추후에 데이터 조회 요청이 들어온다면, Query 서비스를 호출하여 원하는 데이터 포멧에 맞게 만든 Query 전용 도메인 모델을 사용하여 데이터를 가져오는 방식입니다.

여기에서도 DB끼리 데이터 동기화를 시키는게 관건이라고 할 수 있는데, CDC를 사용하거나 kafka와 같은 메세지큐를 사용함으로써 동기화를 하는게 일반적입니다.

또한 DB쪽을 보시면, DB가 command 전용과 query 전용 2개로 나눠져있는데, 하나의 네모로 묶여 있습니다.

이는 DB를 꼭 나누지 않아도 단일 DB CQRS도 가능하다는 것을 알려드리고자 이 2개를 하나의 네모로 묶어놨습니다.

8.

이렇게 CQRS 패턴을 도입한다면 아까의 Order 엔티티는 요구사항이 늘어나도

command 로직과 query 로직이 나눠지면서 쓰기와 읽기 책임이 분리되면서

UI의 변경 즉, 조회 데이터 포멧의 변경이 Order 엔티티까지 미치지 않고, Order 엔티티는 오직 도메인적 요구사항 변경에만 영향을 받을 수 있게 되면서 SRP 까지 만족시킬 수 있게 됩니다.

당연하게도 책임이 정확하게 나눠지면서 유지보수의 장점 또한 챙길 수 있게 되죠.

이렇게 CQRS 명령/쿼리 책임 분리 패턴에 대해서 가볍게 알아봤고

9.

다음으로 알아볼 개념은 이벤트 소싱입니다.

이벤트 소싱이란, 도메인의 상태 변화 자체를 하나의 이벤트로 저장하고, 이 순차적인 이벤트들을 사용하여

현재 데이터가 어떤 상태인지 계산하는 방식을 이벤트 소싱이라고 합니다.

왼쪽에 보이는 json이 기존의 CRUD 방식으로 데이터를 저장하는 구조입니다.

엔티티의 필드값이 json에 표시되어 있고, 데이터를 변경할 때는 update 방식으로 덮어쓰기를 하는

우리가 흔히 RDB를 사용할 때의 방식입니다.

이제 오른쪽이 이벤트 소싱 방식인데, 이벤트 소싱은 데이터 자체를 저장하지 않고, 데이터에 어떤 처리를 했는지를 덮어쓰기가 아닌 기존의 데이터에 append 하는 방식으로 저장을 합니다.

10.

아까 CQRS때 보았던 approve를 예시로 들어보자면

기존의 방식은 직접적으로 상태값을 바꿔주는 메서드였다면, 이벤트 소싱에서는

상태값을 바꾸지 않고, “해당 Order 엔티티에 대해 approve를 했다” 라는 이벤트를 생성하여

이 이벤트 자체를 append 방식으로 저장합니다.

이해를 돕기 위해 오른쪽 플로우 차트를 보면, Order 엔티티를 approve하는 요청이 들어오면

Order의 approve를 호출하게 됩니다.

이때 호출되는 approve는 상태를 변경하는 approve가 아닌 이벤트를 생성하는 approve로

OrderApprovedEvent를 생성하게 됩니다.

이 생성된 이벤트는 Event Store라는 별도의 DB에 저장되게 되는데,

이 저장된 이벤트를 Event Store를 구독하고 있는 조회용 서비스인 컨슈머에서 데이터를 가져와서

Projection 갱신을 하게 됩니다.

여기서 나온 Projection이 이벤트 소싱에 있어서 중요한 개념 중 하나인데,

Projection이란 생성된 이벤트를 기반으로 조회용 데이터 모델로 만들어서 저장하는 과정을 Projection이라고 합니다.

그래서 따로 조회용 DB를 ProjectionDB라고도 부릅니다.

이러한 방식으로 데이터를 저장하는걸 이벤트 소싱이라고 하는데, 이걸 도대체 왜 하는가를 보자면

11.

이벤트 소싱 또한 하나의 전략적 선택으로써 트레이드 오프입니다.

먼저 도입시 좋은점, 장점 먼저 보면 어떠한 처리를 통해 데이터를 변경했는지, 덮어쓰는 것이 아닌 append하여 모든 이벤트 기록을 가지고 있으므로, 모든 변경 이력을 보존하여 모니터링에 유리하고, 내가 원하는 시점의 데이터 상태로 돌아가는 시간여행이 가능합니다.

또한 이벤트 기반 처리이다 보니, 이벤트 기반 시스템이 많이 사용되는 MSA 확장에 유리하다는 장점 또한 존재하며, ProjectionDB 즉 조회용 DB에 장애가 생겨서 데이터가 삭제되어도, Event Store의 이벤트들을 replay 즉 이벤트를 다시 순차적으로 실행시킴으로써 복구가 가능하여 장애 복구에 이점이 있습니다.

반면에 어떤 단점이 있는지 보면, 제가 설명은 매우 간단하게 했지만, 조금만 더 들여다 보면,

모델링을 어떻게 할 것인지, Event Store는 어떤 기술 스택을 사용할 것인지, 이벤트 버전 관리는 어떻게 할 것인지 등등 여러가지 굉장히 복잡한 기술입니다.

또한 이벤트를 계속해서 저장을 해야하다보니, 시간이 지나면 지날 수록 데이터의 양이 너무 많아져

리플레이, 즉 데이터를 읽어 오는게 힘들어질 수 있습니다, 그래서 보통 이벤트 데이터를 전부 저장하지 않고

일정 이벤트를 모아놨다가 현재 데이터 상태를 스냅샷으로 찍어 저장하는 방식을 사용하곤 합니다.

마지막 단점은 Eventually consistent입니다. 이는 궁극적 일관성 이라고 하는데 쉽게 말하자면,

결국 모든 DB는 동기화가 된다. 라는 뜻입니다.

이게 무슨 단점이냐면, 결국 이벤트 소싱 또한 데이터가 변경되어서 이벤트를 저장하면, 이 이벤트를

구독하고 있는 조회용 서비스에서 가져가서 Projection 하는 이 과정에 딜레이가 생겨

실시간성이 떨어질 수 있다는 의미입니다.

결국엔 데이터가 동기화가 되지만, “즉시” 반영되지 않는 실시간성이 떨어진다는 말입니다.

이러한 장단점을 지니고 있는, 데이터의 상태를 변경하지 않고, 이벤트로써 저장하는 방식이

바로 이벤트 소싱이다. 라고 알고 계시면 될 것 같습니다.

12.

그런데 이걸 왜 알아야할까에 대해서 말해보고자 합니다.

제가 왜 이런 주제를 선택해서 발표를 진행하는지라고도 할 수 있겠네요

요즘 기업들 시스템 구조가 어떻습니까

모두 MSA를 지향하고 있습니다.

it 대기업인 네카라쿠배 혹은 넷플릭스나 아마존 또한 MSA를 지향하고 도입중에 있으며

여러 채용공고에서도 MSA의 중요성을 강조하고 있습니다.

MSA, 마이크로 서비스 아키텍처는 결국 장애 전파를 막고, 서비스 확장성을 위해 서비스를 분리시켜서

각 서비스끼리의 통신으로 전체 서비스를 운영하는 시스템 아키텍처인데,

이 CQRS와 이벤트 소싱은 각각 서비스의 분리와 이벤트 기반 데이터 처리를 목적으로 사용되는 기술들입니다. 이러한 목적이 MSA와 밀접한 관계가 있습니다.

MSA를 하려면 CQRS와 이벤트 소싱이 필수야! 까지는 아니지만, MSA에서는

다양한 서비스와 도메인간의 느슨한 결합으로 독립적인 배포가 중요한 아키텍처이기에

많은 기업에서 MSA에 EDA, 이벤트 기반 아키텍처를 CQRS와 함께 도입하면서

느슨한 결합과 도메인 복잡성을 처리하고 있습니다.

그래서 내가 이걸 도입해서 사용해보진 못하더라도, 개념 정도는 알고 있어야 된다라고 생각합니다.

13.

그럼 이제 CQRS가 뭔지도 알았고, 이벤트 소싱도 뭔지 알았고, 내가 이걸 왜 알아야 하는지도 봤으니

본격적으로 CQRS와 이벤트 소싱을 어떻게 함께 사용하는지 알아보겠습니다.

14.

앞서 보았던 CQRS의 다이어그램입니다. command와 query를 나눠서 저장하고 처리하는 구조이죠.

물론 CQRS만 사용하거나 이벤트 소싱만 사용하는 경우도 있지만, 이 CQRS와 이벤트 소싱은 둘이 함께 사용하는 경우도 많습니다.

왜냐하면 어차피 CQRS만 사용할 때에도 command db와 query db는 동기화가 필요하기 때문에,

CDC나 kafka를 사용하여 데이터 동기화를 시키는데, 여기에 이벤트 소싱을 함께 도입하면

15.

이렇게 command DB가 Event Store로 바뀌면서 Projection 갱신으로 데이터 동기화까지 챙겨갈 수 있게 되면서 이벤트 소싱의 장점은 덤으로 챙겨갈 수 있게 되기 때문입니다.

이렇게 도입하면, 이벤트 소싱으로 인한 상태 전이 저장 및 이벤트 기반 처리로 인한 확장성과

CQRS로 인한 책임 분리 및 조회 성능 향상까지 가져갈 수 있습니다.

16.

이렇게 CQRS와 이벤트 소싱을 함께 사용하면 이러한 구조를 띄게 되고,

이렇게 하면 이벤트를 생성하는 write-side인 빨간 박스 서버에서 생성한 이벤트를 통해

데이터가 필요한 파란 박스의 서비스들이 이벤트를 가져가게 되고,

가져간 이벤트들은 각 서비스의 조회 데이터 모델에 맞게 projection 되어서 사용됩니다.

17.

사실 개념만 듣는 것보단 실제 사례를 보는게 더 이해하는데 도움이 될 것같아

실제로 CQRS와 이벤트 기반이 함께 도입된 사례를 들고왔습니다.

우아한 형제들, 배달의 민족이죠.

우아한 형제들에서는 CQRS와 이벤트 기반 아키텍처를 도입한 사례가 총 4가지가 있습니다.

첫번째로 회원 시스템 이벤트 기반 아키텍처

두번째로 배민 스토어 에서의 전시 도메인 CQRS + EDA

EDA는 이벤트 드라이븐 아키텍처, 그냥 이벤트 기반 아키텍처 라는 말입니다.

세번째로는 B마트 전시 도메인에서의 CQRS 적용

마지막으로 주문 시스템에서의 이벤트 소싱이 있습니다.

저는 이 4가지 중 가장 CQRS + 이벤트 소싱에 유사한 2번째 사례를 살펴볼 예정입니다.

18.

해당 내용은 우아한 형제들의 기술 블로그에 가면 모두 볼 수 있고, 일부만 가져와서 간단하게 설명하겠습니다

먼저 도입 배경입니다.

우리가 배달의 민족 앱을 키면 여러가지 상품 리스트와 여러 카테고리, 리뷰, 매장, 쿠폰, 광고 등등 많은 요소를 볼 수 있는데요.

이러한 요소들은 하나의 서비스 같지만 MSA로 구성된 별도의 서비스들에서 관리되는 데이터들입니다.

그래서 항상 배민을 시작할 때, 이러한 데이터들을 모아서 빠르게 사용자에게 제공해야하는 요구사항이 존재했습니다.

19.

하지만 기존의 시스템은 MSA 각각 서비스들끼리 REST API 호출로 데이터들을 주고 받고 메세징하는 구조였어서, 성능에 병목이 생길 수 있을 뿐더러, 여러 장애요소가 존재했습니다.

즉, 주어진 요구사항은 MSA에서의 서비스간 데이터 조회 혹은 동기화 성능이 굉장히 중요하며,

MSA에 알맞는 서비스간의 느슨한 결합을 가진 해결방안이 필요한 것입니다.

20.

그래서 배민은 이러한 REST API 호출 구조를 이벤트 기반으로 변경하고, 각 서비스를 CQRS로 변경하면서,

조회 성능을 높히고 데이터들을 안전하고 빠르게 가져올 수 있게되었습니다.

좀 더 자세히 보자면, 왼쪽에 상품 정보 변경, 판매자 정보 변경, 배달 예상 시간 변경 등등의 서비스에서

더이상 데이터를 업데이트 하는 방식이 아닌 이벤트를 생성해서 kafka에 추가합니다.

여기서의 kafka가 이벤트 소싱에서의 EventStore 이자 이벤트 브로커 역할을 수행하는 것이죠.

이렇게 생성된 이벤트들을 배민스토어가 kafka를 구독하여 가져온 다음, 전시 도메인에 맞게 데이터 모델을 변경 시키고, DynamoDB에 조회용 데이터를 저장 및 Redis 캐싱으로 조회 성능 향상을 구현하였습니다.

사진에서 redis에 X 표시가 되어 있는건, redis가 장애가 나더라도 DynamoDB에서 데이터를 가져와서 처리할 수 있다, 라는걸 보여주기 위해 X 표시가 되어 있는 것이고,

이외에도 많은 고민과 느낀점 등 자세한 내용이 블로그에 나와 있지만,

지금의 발표에서는 모두 다루지 않고, CQRS + 이벤트 소싱이 어떤 상황에서 어떤 느낌으로 사용되는지

이해를 돕는 정도로만 소개를 해봤습니다.

22.

마지막으로는 실무에서의 관점과 도입후 해야할 것들을 소개해드리고 마무리 하겠습니다.

굳이 실무에서의 관점을 넣은 이유는, 사실 취준생으로써 이러한 MSA나 EDA CQRS등등 이런 기술들을

써보기는 많이 어렵습니다, 또한 직접 경험해보는 것과 개념만 인터넷으로 공부하는 것은 큰 차이가 있죠

그럼 경험해볼 수 없는데 어떡하지라고 생각할 수 있습니다.

그래서 저는 항상 실무에서의 관점, 실무에서는 어떤 부분을 신경쓰는지까지 공부해야만,

직접 경험해본 경쟁자들과의 간격을 조금이나만 줄일 수 있다 생각하기때문에

실무에서의 관점을 짧게나마 소개해보겠습니다.

23.

그럼 실무에서의 관점입니다.

정말 실무에서는 CQRS와 이벤트 소싱을 도입하려면 많은 요소들을 고려해야합니다.

먼저 정말 이 기술이 필요한가입니다.

제 발표의 부제목은 기술이 아닌 전략으로써의 접근입니다.

이 CQRS와 이벤트 소싱은 만능해결사가 아닙니다.

프로젝트에 사용해도 되는지, 사용을 피해야하는지를 잘 구분하여 도입해야 합니다.

두번째는 아키텍처가 아닌 ‘조직’ 문제일 수 있다는 것입니다.

“CQRS + 이벤트 소싱은 단순한 설계 기술이 아니라,
조직이 ‘도메인을 책임지고 설계·운영할 수 있는 역량’을 갖췄을 때 비로소 효과가 납니다.”

“즉, 기술보다 조직이 먼저 준비되어야 하는 아키텍처입니다.”

세번째는 운영이 훨씬 어려워진다는 것 입니다.

조회 성능, 서비스간의 느슨한 결합도, 이벤트 기반으로 얻을 수 있는 여러 강점들도 있지만

결국 신경써야할 부분이 그만큼 늘어난다는 말이기도 합니다.

그래서 도입전 운영이 훨씬 어려워진다는 것도 염두해 두어야 하고

마지막으로 무작정 바로 도입하기보단, 점진적으로 CQRS를 먼저, 그 다음 이벤트 소싱을 도입하고

Event Store도 kafka로 시작하는 등, 한번에 시스템을 바꿔버리려 하면

되려 설계가 잘못되어 문제가 발생할 가능성이 크고, 개발 속도도 느려질 수 있기 때문에

현실적인 도입 전략을 세워야 합니다.

24.

그래도 나는 꼭 한번 도입을 해보고싶다 하신다면, 이 5가지의 판단 기준만 확인해보시고, 고려해보시면 될 것같습니다.

먼저 도메인의 복잡성입니다.

도메인이 복잡하지 않는데, CQRS를 사용하여 책임을 분리시킨다?

이건 오버엔지니어링일 뿐 기존의 CRUD 방식을 그대로 사용하는 것이 더 나은 선택입니다.

두번째는 쓰기보다 읽기가 더 많은가? 입니다.

보통 서비스에서 DB의 쓰기와 읽기의 비율은 읽기가 7 쓰기가 3 혹은 읽기가 8 쓰기가 2 정도로 봅니다.

CQRS는 모든 이벤트를 생성하여 저장해야하다보니, 기존의 쓰기 방식보다 더 많은 데이터를 저장하게 되고

이러한 결과를 봤을 때 보통 읽기가 9 쓰기가 1정도의 비율일 때 CQRS가 가장 효율적이다 라고 봅니다.

이 두가지를 만족한다면 CQRS의 도입을 고려해볼만 하며,

세번째는 데이터의 상태 이력 추적이 필요한가 입니다.

이 말은 내 서비스가 데이터가 언제, 어떻게, 왜 바뀌었는지 알아야 하는가라는 말입니다.

예를 들면 주문/결제 서비스에서는 주문 생성 → 승인 → 배송 중 → 배송 완료 →환불/취소 이러한 프로세스를

따라 서비스가 동작해야합니다.

이러한 서비스에서는 데이터가 언제 어떻게 바뀌었는지 알고 있어야, 여러 고객 클레임이나 장애를 추적하는데 편리하고, 그에 맞는 상태 변경 혹은 재처리가 편리해지기 때문에 데이터의 상태 이력 추적이 필요한 서비스 중 하나입니다.

네번째는 데이터의 복구 리플레이가 중요한가? 입니다.

이는 이미 CQRS와 같이 DB를 나누는 것 처럼 분산 DB 환경일 때 고려할 상황입니다.

복구 리플레이는 조회용 DB가 죽었을 때 혹은 장애가 났을 때,

이벤트 Store에 저장된 이벤트들을 순차적으로 다시 실행하여, DB의 데이터를 복구시키는 작업을 뜻합니다.

즉, 데이터 정합성이 중요한가? 라는 질문으로 바꿀 수도 있죠.

이 세번쨰와 네번째를 만족한다면 이벤트 소싱을 고려해 볼만 합니다.

마지막으로 팀 역량 고려입니다.

이 CQRS와 이벤트 소싱은 러닝커브가 높은 기술입니다.

무작정 필요하다고 시작했다가 관리가 제대로 되지 않아 장애가 발생하고, 오히려 독이 될 수도 있는 상황이 발생할 수도 있으며, 도메인에 대한 지식이 부족하거나, 도메인별로 시스템이 잘 나뉘어져있지 않다면

CQRS와 이벤트 소싱은 그 이점을 제대로 발휘하지 못합니다.

따라서 첫번째부터 4번째 까지를 모두 만족하며, 우리 팀원들의 역량이 충분히 도입할만 하다 싶다면

CQRS와 이벤트소싱을 함께 도입하는 방안을 고려해볼만 하다고 생각합니다.

25.

어찌저찌 도입을 끝낸 후에도 CQRS와 이벤트 소싱을 함께 사용하는 것은 할게 많습니다.

1. 운영 도구/관찰성 확보
2. 이벤트 재처리 및
   리플레이 전략
3. Eventual Consistency
   이해와 대응
4. Projection/Read Model
   관리 및 재생성
5. 팀/조직 내부
   개발 프로세스 정비
6. 이벤트 순서 보장 및
   중복 처리
7. 버전 관리 및
   배포 전략

네, 저는 그냥 공부만 해보는 걸 추천드립니다.

물론 실제로 구현에 성공하고 도입후 처리도 깔끔하게 해결한다면

남들과는 비교할 수 없는 이력이 될 수 있겠지만요.

26.

마지막으로 해드릴 말씀은 어떤 기술이던간에 트레이드오프 관계를 이해하는 것은 중요합니다.

CQRS와 이벤트 소싱은 EDA에 있어서 강력한 패턴인것은 맞지만, 굉장한 복잡성이 따라옵니다.

무조건적으로 좋은 기술은 아니라고 말씀 드리고 싶습니다.

또한 발표 주제를 떠나, 어떤 기술을 도입 할 때는 정말 문제상황을 이 구조가 해결해줄 수 있는지 잘 따져보고

기술이 아닌 “문제”를 중심에 놓고 판단해야 한다는 것을 꼭 말씀드리고 싶습니다.