### 데이터 베이스에서 사용되는 키 다섯 가지를 설명해 주세요.
데이터 베이스에서의 키는 조건에 만족하는 레코드를 찾거나 정렬할 때 기준이 되는 속성 또는 속성의 집합을 뜻합니다. 이는 유일성, 최소성, 참조에 따라 다섯 가지가 있습니다.

슈퍼 키(Super Key)는 유일성만을 보장하는 키입니다. 어떤 속성의 조합이든 각 레코드를 구별할 수 있다면 해당 속성을 슈퍼 키가 될 수 있습니다.

후보 키(Candidate Key)는 유일성과 최소성을 모두 만족하는 키입니다. 슈퍼 키 중에서 최소성을 가진 키가 후보 키가 됩니다.

기본 키(Primary Key)는 릴레이션에서 각 레코드를 유일하게 식별하는 주요 키입니다. 후보 키 중 선택되며, 반드시 유일하고 NOT NULL입니다.

대체 키(Alternate Key)는 후보 키 중 기본 키는 제외한 나머지 모든 키입니다.

외래 키(Foreign Key)는 다른 릴레이션의 기본 키를 참조하는 키입니다. 외래 키를 통해 테이블간 관계 표현이 가능합니다.

### DB에서 인덱스를 쓰는 이유에 대해 설명해 주세요.
인덱스는 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회 속도를 높여주는 자료 구조입니다. 테이블의 특정 레코드 위치를 빠르게 알려주는 용도로 쓰게 됩니다.

또한 인덱스를 사용하면 데이터가 정렬된 상태로 저장되므로 정렬된 결과를 빠르게 반환할 수 있습니다. 그리고 유니크 인덱스를 생성하여 중복된 값을 허용하지 않게 함으로써 데이터 무결성을 유지할 수 있습니다.

### hash 테이블 시간복잡도는 O(1)로 트리보다 빠른데 왜 트리를 사용할까요?
hash 테이블은 일대일 대응 연산에만 특화되어 있어 범위 연산이 자주 사용되는 DB 검색에는 적합하지 않습니다. 더불어서 multi column index의 경우 전체 attributes에 대해 조회를 해야 합니다. 그리고 hash 충돌이 발생할 수 있기에 이를 위한 추가적인 작업이 필요할 수도 있습니다.

### 데이터베이스에서 정규화의 목적을 설명해 주세요.
가장 큰 목표는 테이블 간 중복된 데이터를 최소화하여 이상 현상을 방지하는 것입니다. 이를 통해 데이터 무결성을 유지하고, 불필요한 데이터를 최소화시킬 수 있습니다. 또한 테이블 구성을 논리적이고 직관적으로 할 수 있습니다. 마지막으로 데이터베이스 구조 확장이 용이해집니다.

### 제 1정규화에 대해 설명해 주세요.
테이블 컬럼이 하나의 값을 갖도록 테이블을 분리시키는 것을 말합니다. 어떤 릴레이션에 속한 모든 도메인이 원자값으로만 되어 있어야합니다.

### 제 2정규화에 대해 설명해 주세요.
제 1 정규형을 만족하고, 테이블의 모든 컬럼이 완전 함수적 종속을 만족하도록 분리시키는 것을 말합니다. 즉 기본 키에 종속적이지 않거나 기본 키 일부 컬럼들에만 종속적인 컬럼은 분리되어야 합니다.

### 제 3정규화에 대해 설명해 주세요.
제 2 정규형을 만족하고, 테이블에서 이행적 종속을 없애기 위해 분리시키는 것을 말합니다. 속성에 종속적인 속성은 분리되어야 합니다.

### 이상 현상에 대해 설명해 주세요.
이상 현상이란 릴레이션 조작 시 예기치 않게 발생하는 곤란한 현상입니다. 이상 현상의 종류로 삽입, 삭제, 갱신 이상이 있습니다.

삽입 이상은 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상입니다. 예를 들어 어떤 테이블에 직원의 정보를 저장하는데, 특정 부서에 아직 소속되지 않은 직원의 데이터를 삽입할 때 부서 정보가 없어 삽입이 불가능한 경우를 들 수 있습니다.
삭제 이상은 릴레이션에서 한 레코드를 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 발생하는 현상입니다. 예를 들어 부서 정보가 특정 직원에게만 연결돼 있고 그 직원이 퇴사하면서 부서 정보도 함께 삭제되는 경우가 있을 수 있습니다.

갱신 이상은 릴레이션에서 레코드에 있는 속성값을 갱신할 때 일부 레코드의 정보만 갱신되어 정보의 모순이 생기는 현상입니다. 예를 들어 부서 정보가 여러 직원에게 중복되어 저장되어 있고, 부서 정보를 수정할 때 일부 직원만 수정되어 일관성이 깨질 수 있습니다.

### ERD에 대해 설명해 주세요.
ERD(Entity Relationship Diagram)는 요구 분석 사항에서 얻은 엔티티와 속성들의 관계를 그림으로 나타낸 개체-관계 모델입니다.

엔티티는 정의 가능한 사물 또는 개념을 의미하고 이는 곧 데이터베이스의 테이블이 됩니다.
엔티티 속성은 개체가 가지고 있는 속성을 포함합니다. 이는 곧 테이블의 각 필드가 됩니다.

### ERD 엔티티 관계에 대해 설명해 주세요.
엔티티 관계는 외래 키를 어떤 것으로 갖느냐에 따라 식별자/비식별자 관계로 먼저 구분할 수 있습니다. 부모 자식 관계에서 자식의 외래 키가 부모의 기본 키를 그대로 따르면 식별자 관계로 표현할 수 있습니다. 반면 부모의 기본 키를 외래 식별자로 참조해서 일반 속성으로 사용할 경우 비식별자 관계로 표현할 수 있습니다.

한 개체에서 발생할 수 있는 횟수인 카디널리티에 따라서도 일대일/일대다/다대다 관계로 구분할 수 있습니다.

### 데이터 무결성 세 가지에 대해 설명해 주세요.
데이터 무결성은 데이터베이스에서 데이터의 정확성과 일관성을 유지하고 보장하는 중요한 개념입니다. 이 유형에는 개체 무결성, 참조 무결성, 도메인 무결성이 있습니다.

개체 무결성은 모든 테이블이 기본 키를 가져야 하며 기본 키로 선택된 속성은 고유하여야 하고, NOT NULL임을 규정합니다.

참조 무결성은 외래 키의 개념과 관련있으며 모든 외래 키 값은 기본 키 값을 참조함을 규정합니다.

도메인 무결성은 데이터의 모든 열이 정의된 범위에서 선언되도록 규정합니다. (예시. 나이는 음수가 될 수 없음)

### 트랜잭션에 대해서 설명해 주세요.
트랜잭션은 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위입니다. 트랜잭션은 ACID 특징을 갖고 있습니다. Atomicity, 원자성은 트랜잭션을 구성하는 연산 전체가 DB에 모두 반영되거나 혹은 취소되어야 하는 성질입니다. Consistency, 일관성은 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 후의 상태가 같아야 하는 성질입니다. Isolation, 독립성은 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때 서로의 연산에 끼어들 수 없는 성질입니다. Durability, 지속성은 트랜잭션이 성공적으로 완료되었으면 결과는 영구적으로 반영되어야 하는 특징입니다.

### 트랜잭션 연산에 대해 설명해 주세요.
트랜잭션 연산에는 Commit과 Rollback이 있으며 두 연산에 의해 원자성을 보장받습니다. Commit은 하나의 트랜잭션이 성공적으로 끝나고, DB가 일관성 있는 상태에 있거나 하나의 트랜잭션이 끝났을 때 사용하는 연산입니다. Rollback은 하나의 트랜잭션이 비정상적으로 종료되어 트랜잭션 원자성이 깨질 경우 처음부터 다시 시작하거나 부분적으로 연산을 취소하는 연산입니다.

### 트랜잭션이 Isolation을 보장하는 방법에 대해 설명해 주세요.
다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 격리 수준을 정할 수 있습니다. 격리 수준은 여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 문제를 제어하기 위한 메커니즘입니다.

레벨 0의 격리 수준은 Read Uncommitted에 해당합니다. 트랜잭션이 처리 중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용합니다. 이는 DB의 일관성을 유지하는 것이 불가능하기 때문에 Dirty Read, Non-repeatable Read, Phantom Read 문제가 발생할 수 있습니다.

레벨 1의 격리 수준은 Read Committed에 해당합니다. 트랜잭션이 수행되는 동안 다른 트랜잭션이 데이터에 접근할 수 없어 대기하게 됩니다. Commit이 이루어진 트랜잭션만 조회가 가능한 수준입니다. 따라서 Dirty Read는 발생하지 않지만 여전히 Non-repeatble Read는 발생할 수 있습니다.

레벨 2의 격리 수준은 Repeatable Read에 해당합니다. 이는 다른 사용자가 트랜잭션 영역에 해당되는 데이터에 대해 수정을 불가능하게 합니다. 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장합니다. 따라서 Non-repeatble Read는 방지됩니다.

마지막 Serializable은 다른 사용자가 트랜잭션 영역에 해당되는 데이터에 대한 수정, 입력을 불가능하게 합니다. 완벽한 읽기 일관성 모드를 제공하여 Phantom Read를 방지합니다.

### 트랜잭션 격리 수준을 선택하는 기준에 대해 설명해 주세요.
Read Uncommitted는 성능이 중요하고 데이터 일관성이 크게 중요하지 않은 경우에 사용될 수 있습니다.

Read Committed는 대부분의 시스템에서 기본적으로 사용되며, 일반적인 요구 사항을 충족합니다.

Repeatble Read 또는 Serializable은 데이터 일관성이 매우 중요하며, 동시에 여러 트랜잭션이 발생할 가능성이 높은 경우 선택됩니다.

각 격리 수준은 일관성과 성능 간의 트레이드오프를 나타내며, 특정 상황에 맞게 선택되어야 합니다.

### RDB의 특징에 대해 설명해 주세요.
RDB, 관계형 데이터베이스는 데이터가 하나 이상의 열과 행의 테이블에 저장되어 서로 다른 데이터 구조가 어떻게 관련되어 있는지 쉽게 파악하고 이해할 수 있도록 구성된 데이터 베이스입니다.

RDB의 장점으로는 정형화된 데이터를 저장하기 때문에 스키마에 따라 데이터의 형태와 크기를 미리 정할 수 있다는 것이 있습니다. 그리고 트랜잭션을 통해 ACID를 보증하여 안정적인 데이터 관리가 가능합니다. JOIN과 같이 복잡한 조건을 포함하는 데이터 검색이 가능합니다. 데이터 무결성을 개선하는 정규화 기법을 사용할 수 있습니다.

### NoSQL이 나오게 된 이유와 종류에 대해 설명해 주세요.
웹의 성장에 따라 멀티미디어 데이터와 같은 비정형 데이터가 빠른 속도로 대량 생산되고 있습니다. 이런 환경에서 RDB를 적용하면, 데이터의 스키마가 이미 정해져 있어 속성을 자주 추가하고 조정하기에 적합하지 않습니다. 또한 관계를 맺고 있기 때문에 JOIN이 많은 복잡한 쿼리가 만들어질 수 있습니다.

즉 대량의 비정형 데이터의 저장과 유연한 처리를 위해 새로운 대안으로 제시된 것이 NoSQL입니다.

NoSQL 종류에는 대표적으로 MongoDB, Redis 등이 있습니다. MongoDB는 JSON을 통해 데이터에 접근할 수 있고, Document 기반의 DB입니다. 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 확장성이 뛰어납니다. Document를 생성할 때마다 고유한 ObjectID가 생성됩니다. Redis는 인메모리 DB이자 key-value 데이터 모델 기반의 DB입니다. 문자열, set, sorted set, hash, list 데이터를 지원하고, 높은 성능을 제공하며 데이터의 영속성을 옵션으로 지원합니다.

### Redis을 적용하면 적합한 경우에 대해 설명해 주세요.
일반적인 DB가 하드 디스크나 SSD에 저장하는 것과는 달리 Redis는 RAM에 데이터를 저장합니다. 이는 디스크 스캐닝이 필요없어 매우 빠르다는 장점을 가집니다.

데이터 구조가 간단하고 key-value 저장이 적합한 경우 Redis를 적용하기에 적합하다고 볼 수 있습니다. 복잡한 쿼리나 RDB의 JOIN이 필요 없는 간단한 구조에서 효과적으로 사용됩니다.

이전에 검색하거나 계산한 것을 재사용하는 캐싱에 적용하면 빠르게 액세스할 수 있습니다. 이를 통해 반복적인 요청에 대한 응답 시간을 크게 단축할 수 있습니다.

실시간 데이터 처리가 필요한 경우에도 적합합니다. 온라인 광고 노출, 게임 순위표와 같은 상황에서 Redis는 매우 빠른 응답 시간을 제공하여 실시간으로 데이터를 업데이트하고 조회하는 데에 적합합니다.


### RDB와 NoSQL을 비교해서 설명해 주세요.
RDB와 NoSQL은 데이터베이스의 다른 형태로 특징과 용도에 따라 선택됩니다.

RDB는 명확하게 정의된 스키마가 존재하고, 데이터 무결성을 보장할 수 있다는 장점이 있습니다. 이러한 특징때문에 덜 유연한 편이고, 관계를 맺고 있어서 조건에 따라 JOIN이 많은 복잡한 쿼리가 만들어질 수 있습니다.

NoSQL은 스키마가 없어서 유연하여, 저장된 데이터를 쉽게 조정하고 새로운 필드를 추가하는 데 용이하다는 장점을 가집니다. 그러나 유연하다는 특징때문에 데이터 수정 시 모든 컬렉션에서 수행해야 하고, 데이터 중복을 계속 업데이트해야한다는 단점을 가지고 있습니다.

따라서 관계를 맺고 있는 데이터가 자주 변경되거나, 데이터의 스키마가 변경될 여지가 적은 경우 RDB를 선택하는 것이 적합합니다. 반대로 데이터 구조가 변경될 가능성이 크고 데이터 변경에 비해 읽기, 삽입이 많은 경우 NoSQL을 선택하는 것이 적합합니다.