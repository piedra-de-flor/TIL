### Binary Search에 대해 아는대로 설명해 주세요.</br>
Binary search는 탐색 범위를 두 부분으로 분할하면서 찾는 방식으로 O(N)의 시간복잡도를 갖는 완전탐색에 비해 O(logN)의 시간복잡도를 가져 효율적입니다.</br>
정렬된 상태에서만 사용 가능한데, 이는 중간값을 찾아내어 찾고자 하는 값이 중간값보다 작으면 왼쪽 부분, 크면 오른쪽 부분으로 범위를 좁혀가는 방식으로 </br>
동작하기 때문입니다.

### Bubble Sort에 대해서 아는대로 설명해 주세요.
Bubble Sort는 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘입니다.

1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 마지막-1 번째 원소와 마지막 번째 원소를 비교하여 조건에 맞지 않으면 교환합니다.</br> 1회전을 수행하면 가장 큰 원소가 맨 뒤로 이동하므로 2회전은 마지막-2 번째 원소와 마지막-1 번째 원소까지만 비교합니다.

bubble sort의 시간복잡도는 O(N^2)입니다. </br>
기존 원소의 정렬 유무와 관계 없이 전체 탐색을 통해 원소를 비교하므로 최선, 평균, 최악의 경우 모두 시간복잡도가 동일합니다. </br>
공간복잡도는 주어진 배열 안에서 교환을 통해 정렬이 수행되므로 O(N)입니다.

구현이 간단하고, 제자리 정렬로 별도의 메모리 공간을 필요로 하지 않는 것이 장점이지만, 시간복잡도가 전부 O(N^2)이므로 비효율적입니다.

### Selction Sort에 대해서 아는대로 설명해 주세요.
Selection Sort는 정렬 순서에 따라 원소를 넣을 위치는 이미 정해져 있고 어떤 원소를 넣을지 선택하는 정렬 알고리즘입니다.</br>

오름 차순 정렬이라고 가정하겠습니다. 주어진 배열 중에 최솟값을 찾고 그 값을 맨 앞에 위치한 값과 교체합니다.</br>
그런 다음 맨 처음 위치를 뺀 나머지 배열을 동일한 방법으로 교체합니다.

selection sort의 시간복잡도는 O(N^2)입니다. 최선, 평균, 최악의 경우도 동일합니다. </br>
공간복잡도는 주어진 배열 안에서 교환을 통해 정렬이 수행되므로 O(N)입니다.

정렬을 위한 비교 횟수는 많지만 실제 교환 횟수는 최솟값을 N번 교환하기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적입니다. </br>
또한 제자리 정렬로 별도의 메모리 공간을 필요로 하지 않는 것이 장점입니다. 반면 시간복잡도가 비효율적이며 불안정 정렬입니다.

### Insertion Sort에 대해서 아는대로 설명해 주세요.
Insertion Sort는 두 번째 원소부터 시작하여 앞의 원소와 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기면서 지정된 자리에 삽입하여 정렬하는 알고리즘입니다.
</br>

Insertion Sort의 시간복잡도는 평균, 최악의 경우 O(N^2)입니다.
그러나 모두 정렬이 되어있는 경우 한 번씩만 비교를 하므로 O(N)의 시간복잡도를 가집니다. </br>
공간복잡도는 주어진 배열 안에서 교환을 통해 정렬이 수행되므로 O(N)입니다.</br>
단순하고, 이미 정렬된 경우 매우 효율적입니다. 제자리 정렬이자 안정 정렬인 것이 장점입니다. </br>평균과 최악의 경우 O(N^2)의 시간복잡도로 비효율적인 것이 단점입니다.
